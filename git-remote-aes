#!/usr/bin/env node

const { spawn, spawnSync } = require('child_process')
const readline = require('readline')
const { resolve } = require('path')
const MirrorPush = require('./mirror.js')

const handleCapabilities = async () => {
    caps = ["fetch", "push"] //, "option"]
    caps.forEach((s, i) => console.log(s))
    console.log()
}

// handleList: From https://git-scm.com/docs/git-remote-helpers
//
// list
// Lists the refs, one per line, in the format "<value> <name> [<attr>
// …​]". The value may be a hex sha1 hash, "@<dest>" for a symref, or
// "?" to indicate that the helper could not get the value of the
// ref. A space-separated list of attributes follows the name;
// unrecognized attributes are ignored. The list ends with a blank
// line.
//
// list for-push
// Similar to list, except that it is used if and only if the caller 
// wants to the resulting ref list to prepare push commands. A helper 
// supporting both push and fetch can use this to distinguish for which 
// operation the output of list is going to be used, possibly reducing 
// the amount of work that needs to be performed.
// Supported if the helper has the "push" or "export" capability.

const handleList = async (args) => {
    // I believe all this does is what you get by calling
    // git ls-remote -q
    // alternatively we can call git-update-server-info to generate the
    // a file that we send back https://www.git-scm.com/docs/git-update-server-info
    let ls = spawn('git ls-remote -q', [args], {
        shell: true
    })
    let rl = readline.createInterface({
        input: ls.stdout,
        terminal: false
    })

    for await (const line of rl) {
        let tokens = line.split("\t")
        console.log(tokens[0], tokens[1])
        console.error(tokens[0], tokens[1])
    }

    console.log()
}

// TODO: you can push a batch by just space seperating more refspecs 
// XXX it's unclear to me when a batch is used and when it isn't
const GITERN_ENCRYPT_REPO = ".git/gitern/encrypt"
const handlePushBatch = async(address, remote, refspecs) => {
    // create encrypted repo in .git if it doesn't already exist (git init does this for you)
    // e.g. git init .git/gitern/encrypt
    // bare doesn't work for some reason. Might need to set GIT_DIR
    var init = spawnSync('git init', [GITERN_ENCRYPT_REPO], {
        shell: true
    })

    let dsts = []
    for (const refspec of refspecs) {
        var [src, dst] = refspec.split(':')
        dsts.push(dst)

        // using plumbing, mirror.js, mirror relevant commits into .git/gitern/encrypt
        mirror = new MirrorPush(".", GITERN_ENCRYPT_REPO)
        await mirror.mirror(src, remote)
        console.error("COMPLETED MIRROR", src)
    }

    // push to remote from mirror
    var push = spawnSync('git push', [address, ...refspecs], {
        shell: true,
        cwd: resolve(GITERN_ENCRYPT_REPO),
    })

    var status = push.status == 0 ? "ok" : "error"
    for (const dst of dsts) {
        console.error(status, push.stdout.toString())
        console.log(status, dst)
    }

    console.error("COMPLETED PUSH", status, src, dst)
}

// TODO: first fetch into mirror
const handleFetchBatch = async (address, remoteName, refs) => {
    for (const ref of refs) {
        handleFetch(address, remoteName, ref)
    }
}


// TODO: fetch into mirror?
// we'll need to store encrypted objects, then walk through and decrypt them
// git fetch will retreive the remote ref into the mirror
// from there, we'll need to walk the commits we pull down and store them
// in the local repo
const handleFetch = async (address, remote, ref) => {
    let refspec = `${ref}:refs/remotes/${remote}/${ref}`
    console.error("git fetch", address, refspec)
    let fetch = spawnSync('git fetch', [address, refspec], {
        shell: true
    })

    console.log()
}

const main = async () => {
    console.error(process.argv);

    let rl = readline.createInterface({
        input: process.stdin,
        terminal: false
    })

    let remote = process.argv[2]
    let address = "git@gitern.com:" + process.argv[3].slice("aes://".length)
    let pushes = []
    let fetches = []

    for await (const line of rl) {
        console.error(line)
        if (line == "capabilities") {
            handleCapabilities()
        } else if (line.startsWith("list")) {
            await handleList(address)
        } else if (line.startsWith("push")) {
            pushes.push(line.split(' ')[1])
        } else if (line.startsWith("fetch")) {
            fetches.push(line.split(' ')[1])
        } else if (line == "") {
            if (pushes.length > 0) {
                handlePushBatch(address, remote, pushes)
            }
            if (fetches.length > 0) {
                handleFetchBatch(address, remote, fetches)
            }
        }
    }
}

main()