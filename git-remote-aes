#!/usr/bin/env node

const { spawn, spawnSync } = require('child_process');
var readline = require('readline');

function handleCapabilities() {
    caps = ["fetch", "push"] //, "option"]
    caps.forEach((s, i) => console.log(s))
    console.log()
}

// handleList: From https://git-scm.com/docs/git-remote-helpers
//
// list
// Lists the refs, one per line, in the format "<value> <name> [<attr>
// …​]". The value may be a hex sha1 hash, "@<dest>" for a symref, or
// "?" to indicate that the helper could not get the value of the
// ref. A space-separated list of attributes follows the name;
// unrecognized attributes are ignored. The list ends with a blank
// line.
//
// list for-push
// Similar to list, except that it is used if and only if the caller 
// wants to the resulting ref list to prepare push commands. A helper 
// supporting both push and fetch can use this to distinguish for which 
// operation the output of list is going to be used, possibly reducing 
// the amount of work that needs to be performed.
// Supported if the helper has the "push" or "export" capability.

async function handleList(args) {
    // I believe all this does is what you get by calling
    // git ls-remote -q 
    var ls = spawn('git ls-remote -q', [args], {
        shell: true
    })
    var rl = readline.createInterface({
        input: ls.stdout,
        terminal: false
    });

    for await (const line of rl) {
        console.log(line.replace("\t", " "))
    }

    console.log()
}

async function handlePush(address, refspec) {
    var push = spawnSync('git push', [address, refspec], {
        shell: true
    })

    var dst = refspec.split(':')[1]

    if (push.status == 0) {
        console.error("ok", push.stdout.toString())
        console.log("ok", dst)
    } else {
        console.error("error", push.stderr.toString())
        console.log("error", dst)
    }

    console.log()
}

function handleFetch(address, remoteName, ref) {
    var refspec = `${ref}:refs/remotes/${remoteName}/${ref}`
    var fetch = spawnSync('git fetch', [address, refspec], {
        shell: true
    })

    console.log()
}

const main = async() => {
    console.error(process.argv);

    var rl = readline.createInterface({
        input: process.stdin,
        terminal: false
    })

    address = "git@gitern.com:" + process.argv[3].slice("aes://".length)

    for await (const line of rl) {
        console.error(line)
        if (line == "capabilities") {
            handleCapabilities()
        } else if (line.startsWith("list")) {
            await handleList(address)
        } else if (line.startsWith("push")) {
            var refspec = line.split(' ')[1]
            await handlePush(address, refspec)
        } else if (line.startsWith("fetch")) {
            var ref = line.split(' ')[1]
            await handleFetch(address, process.argv[2], ref)
        }
    }
}
main()