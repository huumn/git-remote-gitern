#!/usr/bin/env node

const { spawn } = require('child_process')
const readline = require('readline')
const Mirror = require('./mirror.js')

const handleCapabilities = async () => {
    caps = ["fetch", "push"] //, "option"]
    caps.forEach((s, i) => console.log(s))
    console.log()
}

// handleList: From https://git-scm.com/docs/git-remote-helpers
//
// list
// Lists the refs, one per line, in the format "<value> <name> [<attr>
// …​]". The value may be a hex sha1 hash, "@<dest>" for a symref, or
// "?" to indicate that the helper could not get the value of the
// ref. A space-separated list of attributes follows the name;
// unrecognized attributes are ignored. The list ends with a blank
// line.
//
// list for-push
// Similar to list, except that it is used if and only if the caller 
// wants to the resulting ref list to prepare push commands. A helper 
// supporting both push and fetch can use this to distinguish for which 
// operation the output of list is going to be used, possibly reducing 
// the amount of work that needs to be performed.
// Supported if the helper has the "push" or "export" capability.

const handleList = async (args) => {
    // I believe all this does is what you get by calling
    // git ls-remote -q
    // alternatively we can call git-update-server-info to generate the
    // a file that we send back https://www.git-scm.com/docs/git-update-server-info
    let ls = spawn('git ls-remote -q', [args], {
        shell: true
    })
    let rl = readline.createInterface({
        input: ls.stdout,
        terminal: false
    })

    for await (const line of rl) {
        let tokens = line.split("\t")
        console.log(tokens[0], tokens[1])
        console.error(tokens[0], tokens[1])
    }

    console.log()
}

const GITERN_ENCRYPT_REPO = ".git/gitern/encrypt"
const handlePush = async (address, refspec) => {
    // create encrypted repo in .git if it doesn't already exist (git init does this for you)
    // e.g. git init .git/gitern/encrypt
    var init = spawnSync('git init --bare', [GITERN_ENCRYPT_REPO], {
        shell: true
    })
    // using plumbing, mirror.js, mirror relevant commits into .git/gitern/encrypt

    mirror = new Mirror(".", GITERN_ENCRYPT_REPO)
    var ref = refspec.split(':')[0]
    mirror.mirror(ref)
    console.error("completed mirror")

    // push from encrypted repo to remote


    // TODO: you can push a batch by just space seperating more refspecs 
    // var push = spawnSync('git push', [address, refspec], {
    //     shell: true
    // })

    // var dst = refspec.split(':')[1]

    // if (push.status == 0) {
    //     console.error("ok", push.stdout.toString())
    //     console.log("ok", dst)
    // } else {
    //     console.error("error", push.stderr.toString())
    //     console.log("error", dst)
    // }

    // console.log()
}

const handleFetch = async (address, remoteName, ref) => {
    var refspec = `${ref}:refs/remotes/${remoteName}/${ref}`
    console.error("git fetch", address, refspec)
    var fetch = spawnSync('git fetch', [address, refspec], {
        shell: true
    })

    console.log()
}

const main = async () => {
    console.error(process.argv);

    var rl = readline.createInterface({
        input: process.stdin,
        terminal: false
    })

    address = "git@gitern.com:" + process.argv[3].slice("aes://".length)

    for await (const line of rl) {
        console.error(line)
        if (line == "capabilities") {
            handleCapabilities()
        } else if (line.startsWith("list")) {
            await handleList(address)
        } else if (line.startsWith("push")) {
            var refspec = line.split(' ')[1]
            handlePush(address, refspec)
        } else if (line.startsWith("fetch")) {
            var ref = line.split(' ')[1]
            handleFetch(address, process.argv[2], ref)
        }
    }
}

main()